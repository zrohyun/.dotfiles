osType="$(uname -s)"
case "${osType}" in
    Linux*)     machine=Linux;;
    Darwin*)    machine=Mac;;
    *)          echo "NOT SUPPORTED:${osType}";exit 1
esac

if command -v fzf &>/dev/null; then
    export FZF_BASE=$(which fzf)
# else;
#     case "$machine" in
#         Linux)
#             sudo apt-get install -y fzf
#             ;;
#         Mac)
#             brew install fzf
#             ;;
#         *)
#             echo "Operating system not supported."
#             exit 1
#             ;;
#     esac

#     export FZF_BASE=$(which fzf)
fi

# KUBERNETES(K8S)/CKA/CKAD/CKS
if command -v kubectl &>/dev/null; then
    export oy='-oyaml'
    export dry="--dry-run=client $oy"       # k create deploy nginx --image=nginx $do
    export now="--force --grace-period 0"   # k delete pod x $now
    
    #! 이렇게 다량의 cluster config를 KUBECONFIG로 추가하면 extension에 부담이 될 수가 있다.
    #TODO: 자주 사용하는 것은 config로 기본 설정으로 하고
    # 다른 shell을 이용해 매번 단일 config를 load하고 마지막 load한 config를 기억하는 방식으로 하는 것이
    # 혹시 탐색되는 cluster가 너무 많을 때 extension에 가해지는 부담을 줄일 수도 있을 것 같다.
    set_kubeconfig(){
        export KUBE_DIR=${1:-"$HOME/.kube"}
        alias kube="cd $KUBE_DIR" #'cd $KUBE_DIR && ls -al && cd -'
        # 파일 목록 가져오기
        # export KUBECONFIG=$(find ~/.kube -type f | tr '\n' ':')
        files=($(find "$KUBE_DIR" -maxdepth 1 -type f -name "*config*"))
        # 파일들을 ':'로 연결하여 KUBECONFIG 변수에 할당
        export KUBECONFIG=$(IFS=:; echo "${files[*]}")
    }; set_kubeconfig;
    # unset -f set_kubeconfig;
fi