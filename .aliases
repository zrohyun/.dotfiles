#!/bin/bash
##############################################################################
########################### zrohyun custom aliases ###########################
##############################################################################

# Unix
alias ln="ln -v"
alias mkdir="mkdir -vp"

# handy short cuts #
alias h='history'
alias j='jobs -l'
alias c='clear'
alias now='date'
alias hg='history|grep'
alias shell='echo $SHELL'

if [[ -f /etc/hosts ]]; then
    #TODO: if $UID =0 no sudo
    if [[ $UID == 0 ]]; then
        alias vihosts='vi hosts'
    else
        alias vihosts='sudo vi hosts'
    fi
    alias hosts='cat /etc/hosts'
fi

# TODO: 
# hosts
# hardware: sudo lshw -short
# cpu: cat /proc/cpuinfo
# ram: cat /proc/meminfo
# hdd: fdisk -l
# gpu: nvidia-smi or lspci | grep VGA or sudo lshw -C display or nvtop or nvitop or gpustat

# IP
# if command -v ifconfig &> /dev/null; then
#     alias privateip="ifconfig | grep -A 5 -E 'eth0:|en0:' | grep 'inet ' | awk '{ print $2 }'"
# fi
# if curl -s --max-time 1 ifconfig.me > /dev/null; then
#     alias myip='curl ifconfig.me'
#     alias ip=myip
# elif curl -s --max-time 1 icanhazip.com > /dev/null; then
#     alias myip='curl icanhazip.com'
#     alias ip=myip
# elif command -v dig &> /dev/null; then
#     alias myip='dig +short myip.opendns.com @resolver1.opendns.com'
#     alias ip=myip
#     # alias myip="dig TXT +short o-o.myaddr.l.google.com @ns1.google.com | awk -F'\"' '{ print \$2 }'"
# fi
function print_my_ip_info() {
    # Private IP 찾기
    local private_ip=""
    if command -v ifconfig &> /dev/null; then
        private_ip=$(ifconfig | grep -A 5 -E 'eth0:|en0:' | grep 'inet ' | awk '{ print $2 }')
    fi

    # Public IP 찾기
    local public_ip=""
    if curl -s --max-time 1 ifconfig.me > /dev/null; then
        public_ip=$(curl -s ifconfig.me)
    elif curl -s --max-time 1 icanhazip.com > /dev/null; then
        public_ip=$(curl -s icanhazip.com)
    elif command -v dig &> /dev/null; then
        public_ip=$(dig +short myip.opendns.com @resolver1.opendns.com)
    fi

    # IP 정보 출력
    echo "Private IP: $private_ip"
    echo "Public IP: $public_ip"
}

alias myip=print_my_ip_info
alias ip=myip

if [[ $SHELL == *"zsh"* ]]; then
    alias reload="source $HOME/.zshrc"
    # alias reload="omz reload"
elif [[ $SHELL == *"bash"* ]] && [[ -e $HOME/.bashrc ]]; then
    alias reload=". $HOME/.bashrc"
fi

# Create and enter directory
mkcd() {
    mkdir -vp "$1" && cd "$_"
}

# git
alias gitpush='echo "git pull --rebase -v && git push" && git pull --rebase -v && git push'

#TODO: export 분리, export, path, etc.. load 순서 결정
if command -v vim &>/dev/null; then
    export EDITOR=vim
    export VISUAL=vim
elif command -v hx &>/dev/null; then
    export EDITOR=hx
    export VISUAL=hx
elif command -v vi &>/dev/null; then
    export EDITOR=vi
    export VISUAL=vi
elif command -v nano &>/dev/null; then
    export EDITOR=nano
    export VISUAL=nano
elif command -v emacs &>/dev/null; then
    export EDITOR=emacs
    export VISUAL=emacs
fi

alias e="$EDITOR"
alias v="$VISUAL"

if [[ $machine == 'Linux' ]]; then
    alias os="uname -a && cat /etc/os-release"
    alias catos="cat /etc/os-release"
elif [[ $machine == 'Mac' ]]; then
    alias os="uname -a && sw_vers && system_profiler SPSoftwareDataType"
    alias catos=os
fi

# dotfiles
if [[ -d $HOME/.dotfiles ]]; then
    alias dotfiles="cd $HOME/.dotfiles"
    alias dotfile=dotfiles
    alias dot=dotfiles
fi

# zshrc
alias sourcezsh="source $HOME/.zshrc"
# workspace
set_workspace() {
    WORKSPACE=$HOME
    if [[ -d $HOME/workspace ]]; then
        WORKSPACE=$HOME/workspace
    elif [[ -d $HOME/Desktop/workspace ]]; then
        WORKSPACE=$HOME/Desktop/workspace
    fi
    alias workspace="cd $WORKSPACE"
    alias works=workspace
    alias wsp=workspace
}
set_workspace

# machine directory alias
if [[ $machine == 'Mac' ]]; then
    if [[ -d $HOME ]]; then
        alias home="cd $HOME"
        alias Home=home
    fi

    if [[ -d $HOME/Desktop ]]; then
        alias desktop="cd $HOME/Desktop"
        alias Desktop=desktop
        alias desk=desktop
    fi

    if [[ -d $HOME/Downloads ]]; then
        alias downloads="cd $HOME/Downloads"
        alias Downloads=downloads
        alias download=downloads
        alias Download=downloads
        alias down=downloads
    fi

    if [[ -d $HOME/obsidian-zro ]]; then
        alias obsidian="cd $HOME/obsidian-zro"
        alias obsi="cd $HOME/obsidian-zro"
    fi
fi

# Pretty print the path
alias path='echo $PATH | tr -s ":" "\n"'
alias hey='tmux new -As main'
alias hi=hey

# vim command
if command -v hx &> /dev/null; then
    alias vi=hx
elif command -v vim &> /dev/null; then
    alias vi=vim
# else
#   echo "'hx', 'vim' command is not installed"
fi 

# trash command
if command -v trash &> /dev/null; then
    alias rm='trash -v'
    alias rm-list='trash-list'
# else
#   echo "'trash' command is not installed"
fi 

# trash command
if command -v btop &> /dev/null; then
    alias top='btop'
elif command -v htop &>/dev/null; then
    alias top='htop'
# else
#   echo "'trash' command is not installed"
fi 


# tldr command -> cht
if command -v tldr &> /dev/null; then
    alias man='tldr'
elif command -v cht.sh &>/dev/null; then
    alias man='cht.sh'
elif command -v curl &>/dev/null; then
    function cht() {
        curl cht.sh/$1 # https://github.com/chubin/cheat.sh
    }
    alias man=cht
# else
#     echo "'tldr' command is not installed"
fi

# thefuck command
if command -v thefuck &>/dev/null; then
    eval $(thefuck --alias)
# else
    # echo "'thefuck' command is not installed"
fi

# fd
if command -v fdfind &>/dev/null; then
    alias fd='fdfind -aI'
    alias find=fd
fi

# exa
if command -v exa &>/dev/null; then
    alias ls='exa --icons'
    alias la='ls -lah'
fi

if command -v lsd &>/dev/null; then
    alias ls='lsd'
    alias la='lsd -lah'
    alias ll='lsd -lh'
fi

#TODO: alias 등록하려고 했으나 cd했을 때 $HOME으로 안감.
# 추후 수정하거나 그냥 alias 등록하지 않는 것으로 해야할 듯
# if command -v z &>/dev/null; then
#   alias cd=z
# fi

# NOT MUST HAVE ITEM

# KUBERNETES
if command -v k9s &>/dev/null; then
    alias ks=k9s
fi
if command -v kubectl &>/dev/null; then
    # ref: https://kubernetes.io/docs/reference/kubectl/quick-reference/
    # short alias to set/show context/namespace (only works for bash and bash-compatible shells, current context to be set before using kn to set namespace)
    #TODO: print node info with label or traint or something
    # alias kap='f() { [ "$1" ] && kubectl apply -f $1 } ; f'
    alias kcl='k config get-clusters'
    #TODO: cluster 선택받기 script 함수 작성
    alias kx='f() { [ "$1" ] && kubectl config use-context $1 || kubectl config current-context ; } ; f'
    alias kn='f() { [ "$1" ] && kubectl config set-context --current --namespace $1 || kubectl config view --minify | grep namespace | cut -d" " -f6 ; } ; f'
    # k8s network troubleshooting
    alias knetshoot='f() { kubectl run netshoot --rm -it --image ${1:-nicolaka/netshoot} -- bash } ; f'
    alias kubuntu='f() { kubectl run ubuntu --rm -it --image ${1:-ubuntu:24.04} -- bash } ; f'
fi
# Docker
alias docker_ubuntu='f() { echo "RUN: docker run -it --rm ubuntu:${1:-24.04} bash"; docker run -it --rm ubuntu:${1:-24.04} bash; }; f'
alias dubuntu=docker_ubuntu

# bat
if command -v batcat &>/dev/null; then
    alias bat='batcat'
fi

# duf
if command -v duf &>/dev/null; then
    alias df='duf'
fi

# dust
if command -v dust &>/dev/null; then
    alias du='dust'
fi

# nc, telnet
if command -v nc &>/dev/null; then
    alias nc='echo -ne "99||\x00" | nc -v'
    alias telnet=nc
    #?
    # alias conn=nc
    # alias acl=nc
elif command -v telnet &>/dev/null; then
    conn() {
        # Usage Example
        # $ conn localhost 80
        echo "Connecting with telnet"
        echo -e "^]" | telnet $1 $2
    }
    alias nc=conn
    alias telnet=nc
elif command -v $(which bash) &>/dev/null; then
    conn() {
        verbose=0
        while getopts ":v" opt; do
            case ${opt} in
                v )
                    verbose=1
                    ;;
                \? )
                    echo "Invalid option: $OPTARG" 1>&2
                    return 1
                    ;;
            esac
        done
        shift $((OPTIND -1))

        host=$1
        port=$2

        if [ $verbose -eq 1 ]; then
            echo "Verbose mode on"
            echo "Connecting to $host on port $port"
        fi

        if [ $# -lt 2 ]; then
            echo "Usage: nc [-v verbose] [host] [port]"
            return 1
        fi
        echo "$(which bash) -c echo > '/dev/tcp/$host/$port' 2>/dev/null"
        $(which bash) -c "echo > /dev/tcp/$host/$port" 2>/dev/null
        if [ $? -eq 0 ]; then
            echo "Connection to $host port $port succeeded!"
        else
            echo "Connection to $host port $port failed!"
        fi
    }
    alias nc=conn
    alias telnet=nc
elif command -v curl &>/dev/null; then
    conn() {
        verbose=0
        while getopts ":v" opt; do
            case ${opt} in
                v )
                    verbose=1
                    ;;
                \? )
                    echo "Invalid option: $OPTARG" 1>&2
                    return 1
                    ;;
            esac
        done
        shift $((OPTIND -1))

        host=$1
        port=$2

        if [ $# -lt 2 ]; then
            echo "Usage: nc [-v verbose] [host] [port]"
            return 1
        fi

        if [ $verbose -eq 1 ]; then
            echo "Verbose mode on"
            echo "Connecting to $host on port $port"
            curl -v telnet://$host:$port
        else
            curl telnet://$host:$port
        fi 
    }
    alias nc=conn
    alias telnet=nc
fi

# network
openports() {
    local sudo_cmd=""
    local arg="${1:-default}"

    if [[ "$arg" == "-h" || "$arg" == "help" ]]; then
        echo "Usage: openports [sudo] [command]"
        echo "Options:"
        echo "  sudo     : Run with elevated privileges (requires sudo)"
        echo "  command  : Specify a specific command (netstat, lsof, nmap, ss)"
        echo "  -P       : [TODO]Show the PID of open ports"
        # TODO: Header column별로 filtering하기
        return 0
    fi

    if [[ "$arg" == "sudo" ]]; then
        if command -v sudo &>/dev/null; then
            if sudo -v &>/dev/null; then
                sudo_cmd="sudo"
                arg="${2:-default}"
            else
                echo "Error: sudo permission is required to run this command."
                return 1
            fi
        else
            echo "Error: sudo command not found. Please install sudo."
            return 1
        fi
    fi

    # TODO: if commands안에 $cmd가 없다면 
    local commands=("lsof" "netstat" "nmap" "ss")

    for cmd in "${commands[@]}"; do
        if [[ $arg == "default" ]] || [[ $cmd == $arg ]]; then
            if command -v "$cmd" &>/dev/null; then
                echo "Checking open ports using $cmd..."
                case "$cmd" in
                    "lsof")
                        # echo "$sudo_cmd lsof -i -P -n | awk 'NR==1 || $NF ~ /LISTEN/'"
                        # $sudo_cmd lsof -i -P -n | awk 'NR==1 || $NF ~ /LISTEN/'
                        echo "$sudo_cmd lsof -i -P -n | awk 'NR==1 {print $1, $2, $3, $8, $9} $NF ~ /LISTEN/ {print $1, $2, $3, $8, $9}' | column -t"
                        $sudo_cmd lsof -i -P -n | awk 'NR==1 {print $1, $2, $3, $8, $9} $NF ~ /LISTEN/ {print $1, $2, $3, $8, $9}' | column -t
                        ;;
                    "netstat")
                        if [[ $machine == "Mac" ]]; then 
                            echo "$sudo_cmd netstat -anv -ptcp | awk 'NR==2 || /LISTEN/'"
                            $sudo_cmd netstat -anv -ptcp | awk 'NR==2 || /LISTEN/'
                        elif [[ $machine == "Linux" ]]; then
                            echo "$sudo_cmd netstat -tulpneav tcp | awk 'NR==2 || /LISTEN/'"
                            $sudo_cmd netstat -tulpneav tcp | awk 'NR==2 || /LISTEN/'
                        fi
                        ;;
                    "ss")
                        echo "$sudo_cmd ss -tuln | grep LISTEN"
                        $sudo_cmd ss -tuln | grep LISTEN
                        ;;
                    "nmap")
                        echo "$sudo_cmd nmap -p 1-65535 localhost"
                        $sudo_cmd nmap -p 1-65535 localhost
                        ;;
                esac
                return 0
            else
                echo "$cmd is not installed"
                return 1
            fi
        fi
    done

    echo "No suitable command found for checking open ports."
    return 1
}

select_kubeconfig() {
    export KUBE_DIR=${1:-"$HOME/.kube"}
    # 파일 목록 가져오기
    files=($(find "$KUBE_DIR" -type f -name "*config*"))
    
    if command -v fzf >/dev/null 2>&1; then
        # fzf가 설치되어 있으면 fzf를 사용하여 파일 선택
        selected_config=$(printf "%s\n" "${files[@]}" | fzf)
    elif command -v select >/dev/null 2>&1; then
        # fzf가 없으면 select 문을 사용하여 파일 선택
        echo "fzf is not installed. Please select a file by typing the number."
        select selected_config in "${files[@]}"; do
            if [ -n "$selected_config" ]; then
                break
            else
                echo "Invalid selection. Please try again."
            fi
        done
    else
        # 파일 목록을 사용자에게 표시
        echo "Select a file by entering the corresponding number:"
        for i in "${!files[@]}"; do
        echo "[$i] ${files[$i]##*/}"
        done

        # 사용자 입력 받기
        read -p "Enter number: " file_index

        # 입력값 검증
        if ! [[ "$file_index" =~ ^[0-9]+$ ]] || [ "$file_index" -ge "${#files[@]}" ]; then
        echo "Invalid selection"
        exit 1
        fi

        # 선택한 파일 경로
        selected_file="${files[$file_index]}"
    fi

    # 선택된 파일이 있으면 KUBECONFIG에 할당
    if [ -n "$selected_config" ]; then
        export KUBECONFIG="$selected_config"
        echo "KUBECONFIG set to $selected_config"
    else
        # 기본 config $HOME/.kube/config
        # export KUBECONFIG="${selected_config:-$HOME/.kube/config}"
        echo "No kubeconfig selected."
    fi
}
alias sk="select_kubeconfig"